# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QEzScX9lyU0bHMeAKAsPW32WhMd4Ccrw
"""

import torch
from torch import nn
import torch.nn.functional as F

class NHPLSTMCell(nn.Module):
    """ Update LSTM paramters """
    def __init__(self, hidden_size):
        super(NHPLSTMCell, self).__init__()

        self.input_g = nn.Linear(2*hidden_size, hidden_size)
        self.forget_g = nn.Linear(2*hidden_size, hidden_size)
        self.output_g = nn.Linear(2*hidden_size, hidden_size)
        self.input_target = nn.Linear(2*hidden_size, hidden_size)
        self.forget_target = nn.Linear(2*hidden_size, hidden_size)
        self.z_gate = nn.Linear(2*hidden_size, hidden_size)
        self.decay_g = nn.Linear(2*hidden_size, hidden_size)

    def forward(self, event, hidden, cell, cell_target):

        input = torch.cat((event, hidden), dim=1)

        input_gate = torch.sigmoid(self.input_g(input))
        forget_gate = torch.sigmoid(self.forget_g(input))
        input_gate_target = torch.sigmoid(self.input_target(input))
        forget_gate_target = torch.sigmoid(self.forget_target(input))
        output_gate = torch.sigmoid(self.output_g(input))  
        z_gate = torch.tanh(self.z_gate(input))
        decay_cell = F.softplus(self.decay_g(input))

        cell = forget_gate * cell + input_gate * z_gate
        cell_target = input_gate_target * cell_target + input_gate_target * z_gate

        return cell, cell_target, output_gate, decay_cell


class NHPModel(nn.Module):
    """ Continuous time LSTM network with decay function """
    def __init__(self, hidden_size,  device, emb_size=7, batch_first=True):
        super(NHPModel, self).__init__()
        
        self.hidden_size = hidden_size
        self.emb_size = emb_size
        self.batch_first = batch_first
        self.device = device

        self.LSTM_cell = NHPLSTMCell(self.hidden_size)
        self.Embedding = nn.Embedding(self.emb_size+1, self.hidden_size)
        self.intensity_layer = nn.Sequential(
                              nn.Linear(self.hidden_size, self.emb_size),
                              nn.Softplus())

    def init_states(self, batch_size):
        """      
        Initialize the hidden state and the cell state.
        """

        self.hidden_decay = torch.zeros(batch_size, self.hidden_size, dtype=torch.float, device=self.device)
        self.cell_decay = torch.zeros(batch_size, self.hidden_size, dtype=torch.float, device=self.device)
        self.cell_target = torch.zeros(batch_size, self.hidden_size, dtype=torch.float, device=self.device)
        self.cell = torch.zeros(batch_size, self.hidden_size, dtype=torch.float, device=self.device)

    def decay_cell(self, cell, cell_target, output_gate, decay_cell, T):
        """
        Compute decay parameters
        Input:
            cell - cell state
            cell_target - target cell state 
            output_gate - LSTM output
            decay_cell - rate of decay
            T - interval between events
        """
        cell_decay = cell_target + (cell - cell_target) * torch.exp(-decay_cell * T.view(-1,1))
        hidden_decay = output_gate * torch.tanh(cell)

        return cell_decay, hidden_decay

    def forward(self, event_seqs, duration_seqs, batch_first = True):
        
        batch_size, batch_len = event_seqs.shape

        hidden_t, cell_t, cell_target_t, output_t, decay_t = [], [], [], [], []

        for i in range(batch_len):

            self.init_states(batch_size)
            cell, self.cell_target, output, decay = self.LSTM_cell(self.Embedding(event_seqs[:,i]), self.hidden_decay, self.cell_decay, self.cell_target)
            self.cell_decay, self.hidden_decay = self.decay_cell(cell, self.cell_target, output, decay, duration_seqs[:,i])

            hidden_t.append(self.hidden_decay)
            cell_t.append(cell)
            cell_target_t.append(self.cell_target)
            output_t.append(output)
            decay_t.append(decay)
        
        return  [hidden_t, cell_t, cell_target_t, output_t, decay_t]